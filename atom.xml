<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mazhuang19981201.github.io/</id>
    <title>马壮的博客</title>
    <updated>2020-04-05T12:19:35.563Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mazhuang19981201.github.io/"/>
    <link rel="self" href="https://mazhuang19981201.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://mazhuang19981201.github.io//images/avatar.png</logo>
    <icon>https://mazhuang19981201.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, 马壮的博客</rights>
    <entry>
        <title type="html"><![CDATA[springdata jpa学习总结]]></title>
        <id>https://mazhuang19981201.github.io//post/springdata-jpa-xue-xi-zong-jie</id>
        <link href="https://mazhuang19981201.github.io//post/springdata-jpa-xue-xi-zong-jie">
        </link>
        <updated>2020-04-05T11:45:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jpa-的介绍">jpa 的介绍</h1>
<p>JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。<br>
JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<h1 id="springdata-jpa-介绍">springdata jpa 介绍</h1>
<p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！<br>
Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。</p>
<h2 id="springjpa快速入门">Springjpa快速入门</h2>
<p>1.依赖<br>
<properties><br>
&lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;<br>
&lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt;<br>
&lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;<br>
&lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;<br>
&lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;<br>
&lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;<br>
</properties></p>
<pre><code>&lt;dependencies&gt;
    &lt;!-- junit单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.9&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    
    &lt;!-- spring beg --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.6.8&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- spring end --&gt;

    &lt;!-- hibernate beg --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;version&gt;${hibernate.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
        &lt;version&gt;${hibernate.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
        &lt;version&gt;5.2.1.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- hibernate end --&gt;

    &lt;!-- c3p0 beg --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;c3p0&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;${c3p0.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- c3p0 end --&gt;

    &lt;!-- log end --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;${log4j.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log end --&gt;

    
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;${mysql.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
        &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
        &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- el beg 使用spring data jpa 必须引入 --&gt;
    &lt;dependency&gt;  
        &lt;groupId&gt;javax.el&lt;/groupId&gt;  
        &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;  
        &lt;version&gt;2.2.4&lt;/version&gt;  
    &lt;/dependency&gt;  
      
    &lt;dependency&gt;  
        &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;  
        &lt;artifactId&gt;javax.el&lt;/artifactId&gt;  
        &lt;version&gt;2.2.4&lt;/version&gt;  
    &lt;/dependency&gt; 
    &lt;!-- el end --&gt;
&lt;/dependencies&gt;
2.整合Springdata jpa和spring
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre>
<p><beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
		http://www.springframework.org/schema/data/jpa 
		http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"></p>
<pre><code>&lt;!-- 1.dataSource 配置数据库连接池--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
	&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
	&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/jpa&quot; /&gt;
	&lt;property name=&quot;user&quot; value=&quot;root&quot; /&gt;
	&lt;property name=&quot;password&quot; value=&quot;111111&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 2.配置entityManagerFactory --&gt;
&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
	&lt;property name=&quot;packagesToScan&quot; value=&quot;cn.itcast.entity&quot; /&gt;
	&lt;property name=&quot;persistenceProvider&quot;&gt;
		&lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot; /&gt;
	&lt;/property&gt;
	&lt;!--JPA的供应商适配器--&gt;
	&lt;property name=&quot;jpaVendorAdapter&quot;&gt;
		&lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;
			&lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;
			&lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;
			&lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;
			&lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
	&lt;property name=&quot;jpaDialect&quot;&gt;
		&lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot; /&gt;
	&lt;/property&gt;
&lt;/bean&gt;


&lt;!-- 3.事务管理器--&gt;
&lt;!-- JPA事务管理器  --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;
	&lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 整合spring data jpa--&gt;
&lt;jpa:repositories base-package=&quot;cn.itcast.dao&quot;
	transaction-manager-ref=&quot;transactionManager&quot;
	entity-manager-factory-ref=&quot;entityManagerFactory&quot;&gt;&lt;/jpa:repositories&gt;
	
&lt;!-- 4.txAdvice--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
	&lt;tx:attributes&gt;
		&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
		&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;
		&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
		&lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
		&lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;
		&lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
		&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
	&lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!-- 5.aop--&gt;
&lt;aop:config&gt;
	&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.itcast.service.*.*(..))&quot; /&gt;
	&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot; /&gt;
&lt;/aop:config&gt;

&lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt;
	
&lt;!--组装其它 配置文件--&gt;
</code></pre>
</beans>
# 使用注解配置实体类和关系表的映射关系
@Entity //声明实体类
@Table(name="cst_customer") //建立实体类和表的映射关系
public class Customer {
<pre><code>@Id//声明当前私有属性为主键
@GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略
@Column(name=&quot;cust_id&quot;) //指定和表中cust_id字段的映射关系
private Long custId;

@Column(name=&quot;cust_name&quot;) //指定和表中cust_name字段的映射关系
private String custName;

@Column(name=&quot;cust_source&quot;)//指定和表中cust_source字段的映射关系
private String custSource;

@Column(name=&quot;cust_industry&quot;)//指定和表中cust_industry字段的映射关系
private String custIndustry;

@Column(name=&quot;cust_level&quot;)//指定和表中cust_level字段的映射关系
private String custLevel;

@Column(name=&quot;cust_address&quot;)//指定和表中cust_address字段的映射关系
private String custAddress;

@Column(name=&quot;cust_phone&quot;)//指定和表中cust_phone字段的映射关系
private String custPhone;
..... getter和setter
## 在Dao层的接口需要满足下面规范
/**
* JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作
* JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作）
*/
</code></pre>
<p>public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor<Customer> {<br>
}</p>
<h1 id="springdata-jpa的基本crud操作">Springdata jpa的基本CRUD操作</h1>
<p>保存信息：<br>
<img src="https://mazhuang19981201.github.io//post-images/1586087843055.png" alt=""><br>
删除信息：<br>
<img src="https://mazhuang19981201.github.io//post-images/1586087879705.png" alt=""><br>
修改信息：<br>
<img src="https://mazhuang19981201.github.io//post-images/1586087925088.png" alt=""><br>
查询单个信息：<br>
<img src="https://mazhuang19981201.github.io//post-images/1586088001596.png" alt=""></p>
<h1 id="springdata-jpa的jpql操作">springdata jpa的jpql操作</h1>
<p>在执行查询时，只需要在接口的方法上面加上相应jpql语句的@Query注解，可以同参数位置，也可以在？后加入索引。<br>
<img src="https://mazhuang19981201.github.io//post-images/1586088125590.png" alt=""><br>
在执行修改操作时，在以上步骤的基础上，加入@Modifying注解<br>
<img src="https://mazhuang19981201.github.io//post-images/1586088220815.png" alt=""></p>
<h1 id="springdata-jpa-原生sql查询">Springdata jpa 原生sql查询</h1>
<figure data-type="image" tabindex="1"><img src="https://mazhuang19981201.github.io//post-images/1586088296537.png" alt=""></figure>
<h1 id="springdata-jpa-方法名查询">springdata jpa 方法名查询</h1>
<p><img src="https://mazhuang19981201.github.io//post-images/1586088498337.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088505033.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088508596.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088511984.png" alt=""></p>
<h1 id="使用specifications完成复杂查询">使用Specifications完成复杂查询</h1>
<figure data-type="image" tabindex="2"><img src="https://mazhuang19981201.github.io//post-images/1586088654073.png" alt=""></figure>
<h2 id="分页查询">分页查询</h2>
<p><img src="https://mazhuang19981201.github.io//post-images/1586088682490.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088735867.png" alt=""></p>
<h1 id="多表关系描述">多表关系描述</h1>
<p><img src="https://mazhuang19981201.github.io//post-images/1586088785835.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088821500.png" alt=""></p>
<h2 id="多对多关系">多对多关系</h2>
<p><img src="https://mazhuang19981201.github.io//post-images/1586088938099.png" alt=""><br>
<img src="https://mazhuang19981201.github.io//post-images/1586088942923.png" alt=""><br>
其他操作与hibernate类型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程学习总结]]></title>
        <id>https://mazhuang19981201.github.io//post/duo-xian-cheng-xue-xi-zong-jie</id>
        <link href="https://mazhuang19981201.github.io//post/duo-xian-cheng-xue-xi-zong-jie">
        </link>
        <updated>2020-03-28T05:43:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多线程的实现方式">多线程的实现方式</h1>
<p>1.继承Thread类，重写run方法。<br>
<img src="https://mazhuang19981201.github.io//post-images/1585374327048.png" alt=""><br>
2.实现Runable接口，重写接口中的run方法，用start方法来启动线程<br>
<img src="https://mazhuang19981201.github.io//post-images/1585374415872.png" alt=""><br>
3.Runable相对于Thread的优势<br>
（1）适合多个相同的程序代码的线程去共享一个资源<br>
（2）可以避免java中单继承的局限性<br>
（3）增加程序的健壮性，实现解耦，代码可以被多个线程共享，代码和线程独立<br>
（4）线程池只能放入实现Runable或者是Callable类线程，不能直接放入继承Thread的类</p>
<h1 id="线程安全问题解决方案">线程安全问题解决方案</h1>
<h2 id="线程同步">线程同步</h2>
<p>1.同步代码块<br>
（1）锁对象，可以是任意类型<br>
（2）多个线程对象，要使用同一把锁<br>
<img src="https://mazhuang19981201.github.io//post-images/1585374781827.png" alt=""><br>
2.同步方法<br>
（1）使用synchronized修饰的方法，保证A线程使用该方法时，其他线程只能方法外等候。<br>
（2）同步方法实际上是吧this作为锁对象<br>
<img src="https://mazhuang19981201.github.io//post-images/1585374922056.png" alt=""><br>
3.静态同步方法<br>
（1）在同步方法的基础上使用static修饰<br>
（2）静态同步方法实际上是把当前类的.class作为锁对象<br>
4.Lock锁<br>
（1） java.util. concurrent. locks . Lock机制提供了比synchronized代码块和                     synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都                     有,除此之外更强大,更体现面向对象。<br>
（2）<br>
<img src="https://mazhuang19981201.github.io//post-images/1585375228208.png" alt=""></p>
<h1 id="线程状态概述">线程状态概述</h1>
<figure data-type="image" tabindex="1"><img src="https://mazhuang19981201.github.io//post-images/1585377771710.png" alt=""></figure>
<h2 id="什么是等待唤醒机制">什么是等待唤醒机制</h2>
<pre><code> 这是多个线程间的一种协作机制。 谈到线程我们经常想到的是线程间的竞争( race ) ,比如去争夺锁,但这并不是故事的全部,线程间也会有协作机制。就好比在公司里你和你的同事们,你们可能存在在晋升时的竞争,但更多时候你们更多是一起合作以完成某些任务。
 就是在一个线程进行了规定操作后,就进入等待状态( wait() ),等待其他线程执行完他们的指定代码过后 再将其唤醒( notify() ) ;在有多个线程进行等待时，如果需要,可以使用notifAll()来唤醒所有的等待线程。
 wait/notify就是线程间的一种协作机制。
</code></pre>
<h2 id="等待唤醒中的方法">等待唤醒中的方法</h2>
<pre><code> 等待唤醒机制就是用于解决线程间通信的问题的,使用到的3个方法的含义如下:
  wait :线程不再活动,不再参与调度,进入waitset中,因此不会浪费CPU资源,也不会去竞争锁了,这时的线程状态即是WAITING。它还要等着别的线程执行一个特别的动作,也即是&quot;通知( notify )“在这个对象上等待的线程从wait set中释放出来,重新进入到调度队列( ready queue )中。
  notify :则选取所通知对象的wait set中的一个线程释放;例如,餐馆有空位置后,等候就餐最久的顾客最先入座。
  notifyAll :则释放所通知对象的wait set.上的全部线程。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java面试题第二部分（容器部分）]]></title>
        <id>https://mazhuang19981201.github.io//post/java-mian-shi-ti-di-er-bu-fen-rong-qi-bu-fen</id>
        <link href="https://mazhuang19981201.github.io//post/java-mian-shi-ti-di-er-bu-fen-rong-qi-bu-fen">
        </link>
        <updated>2020-03-28T02:59:30.000Z</updated>
        <content type="html"><![CDATA[<p>请点开下面连接进入：<br>
<a href="https://mp.weixin.qq.com/s/Yl9pTaQYKwf0rZ6InG9OZg">java容器部分面试题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java面试题第一模块 java基础部分]]></title>
        <id>https://mazhuang19981201.github.io//post/java-mian-shi-ti-di-yi-mo-kuai-java-ji-chu-bu-fen</id>
        <link href="https://mazhuang19981201.github.io//post/java-mian-shi-ti-di-yi-mo-kuai-java-ji-chu-bu-fen">
        </link>
        <updated>2020-03-26T04:33:43.000Z</updated>
        <content type="html"><![CDATA[<p>最近在知乎上看到了一些不错的java面试题，感觉质量挺高的，在此记录一下：<br>
<a href="https://mp.weixin.qq.com/s/IBbD3CmVWsTL9ymHg6gGGA">知乎面试题第一部分</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSONView插件的坑]]></title>
        <id>https://mazhuang19981201.github.io//post/jsonview-cha-jian-de-keng</id>
        <link href="https://mazhuang19981201.github.io//post/jsonview-cha-jian-de-keng">
        </link>
        <updated>2020-03-25T16:07:11.000Z</updated>
        <content type="html"><![CDATA[<p>由于之前在测试项目时，后端的返回数据为json格式，由于直接响应的页面时，它的可读性不是很高，所以我就下载了一个插件，叫做JSONView，使用插件后自我感觉良好，显示的json的进行了格式化可读性也比较高。<br>
<img src="https://mazhuang19981201.github.io//post-images/1585152632865.png" alt=""><br>
但是之后对数据库中的信息进行添加操作时，发现了一个很奇妙的bug，就是如果在主键自增的基础上，在添加信息时，总是把相同的一个信息同时添加两条记录，在无数次查看后端代码，总是发现不了问题所在，最后在谷歌浏览器的抓包工具上发现了问题<br>
<img src="https://mazhuang19981201.github.io//post-images/1585152809741.png" alt=""><br>
JSONView插件在启动状态下，向后端发送请求时，会发送两次请求，当我把JSONView插件关闭掉之后，这个问题就不存在了。<br>
具体为什么会发送两次请求，欢迎大佬前来指点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在maven中使用tomcat插件无法启动的问题]]></title>
        <id>https://mazhuang19981201.github.io//post/zai-maven-zhong-shi-yong-tomcat-cha-jian-wu-fa-qi-dong-de-wen-ti</id>
        <link href="https://mazhuang19981201.github.io//post/zai-maven-zhong-shi-yong-tomcat-cha-jian-wu-fa-qi-dong-de-wen-ti">
        </link>
        <updated>2020-03-25T15:15:35.000Z</updated>
        <content type="html"><![CDATA[<p>在近在写一个项目的时候，突然遇到了一个问题，我的项目用本地的tomcat启动没有任何的问题，然而当我用maven的tomcat插件的时候，突然就报出了一个令我百思不得其解的错误。如下：<br>
<img src="https://mazhuang19981201.github.io//post-images/1585149723987.png" alt=""><br>
我在百度上面找了好多的解决方案还是没有找到真正的解决问题的方案。最后发现是在刚开始写程序时，在我的jdk的Java\jdk1.8.0_181\jre\lib\ext这个目录下放了servler-api.jar<br>
<img src="https://mazhuang19981201.github.io//post-images/1585150218331.png" alt=""><br>
在jdk运行时，jdk自身的servlet-api插件和maven的tomcat插件发生了冲突，删除掉jdk的servlet-api.jar就可以运行了。</p>
]]></content>
    </entry>
</feed>